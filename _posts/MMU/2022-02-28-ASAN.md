---
layout: post
title:  "GUN GCC Address/Memory/Leak Sanitizers Tools"
date:   2022-02-28 06:00:00 +0800
categories: [MMU]
excerpt: HugePage.
tags:
  - MMU
---

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L0.PNG)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI100100.png)

#### 目录

> - [ASAN 基础原理](#A)
>
> - [ASAN 基础使用手册](#B)
>
> - ASAN 经典使用案例
>
>   - [ASAN 解析悬浮指针/野指针案例](#C0)
>
>   - [ASAN 解析堆溢出案例](#C1)
>
>   - [ASAN 解析栈溢出案例](#C2)
>
>   - [ASAN 解析全局缓冲区溢出案例](#C3)
>
>   - [ASAN 解析引用返回局部变量内存案例](#C4)
>
>   - [ASAN 解析使用已释放局部变量内存案例](#C5)
>
>   - [ASAN 解析使用未初始化内存案例](#C6)
>
>   - [ASAN 解析内存泄露案例](#C7)
>
> - ASAN 进阶研究
>
>   - [GUN GCC 编译选项研究](http://www.cppblog.com/markqian86/archive/2018/04/17/215594.html)
>
>   - [GUN GCC ASAN 原理分析](https://zhuanlan.zhihu.com/p/338158556)
>
>   - [源码编译 ASAN 版 GUN GCC](#D2)
>
> - [附录/捐赠](#Z0)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------------

<span id="A"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000H.jpg)

#### ASAN 基础原理

ASAN 全称 Address Sanitizer, 其包含了 Address Sanitizer、Memory Sanitizer 和 Leak Sanitizer 都是最初由 Google 开发的，用于运行时检测 C/C++ 程序中的内存错误和多线程 data race的。ASAN 主要用于运行时检测程序中的内存错误，另外 ASAN 除了可以发现堆上的内存越界 (Out-Of-Range), 还可以检查栈和全局变量的越界，最后 ASAN 还可以检查内存泄露.  ASAN 弥补了现有一些工具的很多不足，代表了先进生产力的发展方向, 比如它们都采用了 CTI(CompileTime Instrumentation) 技术，即在编译时进行代码插入，运行速度快，比传统的 Valgrind 等工具速度上要快一个数量级, 另外它们的输出信息都非常详细，方便快速地定位问题. ASAN 由编译器的插桩模块和替换 malloc/free 函数的运行库组成，ASAN 可以探测如下类型的错误:

* Use after free (为悬浮指针赋值)
* Heap buffer overflow (堆溢出)
* Stack buffer overflow (栈溢出)
* Global buffer overflow (全局缓冲区溢出)
* Use after return (通过返回值访问局部变量的内存)
* Use after scope (访问已经释放的局部变量的内存)
* Initialization order bugs (使用未初始化的内存)
* Memory leaks (内存泄露)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001347.png)

上图是一个简单的堆溢出案例，可以看到 array[] 数组一共包含了 10 个程序，但函数对 array[10] 进行了赋值，此时已经超出了堆栈的范围，如果程序运行可能会触发错误。那么接下来讲解一下如果使用 GUN GCC 的 ASAN 工具在程序运行时找出并分析堆栈泄露的问题。GCC-4.8 之后就默认支持 ASAN 工具, 可以在编译 C/C++ 源码时带上指定的参数即可，开发者也可以通过源码编译 GCC 时打开 ASAN 相关的配置:

{% highlight c %}
# CFLAGS for GCC
CFLAGS += -fsanitize=leak
CFLAGS += -fsanitize=address
CFLAGS += -fno-omit-frame-pointer
CFLAGS += -fno-optimize-sibling-calls -O1 -g
#CFLAGS += -fsanitize=memory
{% endhighlight %}

GUN GCC 源码编译的时候添加上诉的编译参数，ASAN 工具的插桩模块会向源码中添加指定的代码，这些代码就是 ASAN 运行的基础代码，另外 ASAN 工具的运行需要动态运行库 libasan, 因此开发者需要根据不同的发行版安装 libasan 库，libasan 库会在程序运行的时候动态替换 malloc/free 函数，以此对程序的内存进行监听。最后可以查看 ASAN 工具运行时候的效果:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001346.png)

程序 BiscuitOS-ASAN-default 运行的时候，ASAN 工具检测到有栈溢出，那么 ASAN 在进程堆移除的时候终止了运行，然后抛出调试信息，首先红色字符串描述内存错误的类型，然后基于错误类型给出了发生错误的虚拟内存地址。ASAN 同样也会打印处当前进程的堆栈调用信息，另外 ASAN 的 SUMMAY 字段会给出具体发生内存错误的地址。接下来是 ASAN 本身的一部分调试信息。以上便是 ASAN 工具分析内存问题的流程，那么接下来开发者可以基于本文了解更多关于 ASAN 的信息和实践内容.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------------

<span id="B"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000Q.jpg)

#### ASAN 基础使用手册

GUN GCC-4.8 之后的版本就默认支持 ASAN 工具，可以在编译 C/C++ 程序时使用指定的 CFLAGS 参数就可以在运行时使用 ASAN 工具，本节重点介绍在不同的环境下如何使用 ASAN 工具。本节在 BiscuitOS 上实践进行讲解，首先准备所需的环境，如果没有安装 GCC，请使用如下命令:

{% highlight c %}
# Running on Ubuntu
sudo apt-get install -y gcc
gcc --version
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001348.png)

如果开发者的 GUN GCC 版本小于 4.8，那么需要额外源码编译 ASAN 版的 GUN GCC, 请参考如下章节:

> [源码编译 ASAN 版 GUN GCC](#D2)

由于 ASAN 运行时需要使用 libasan 库动态替换 malloc/free 函数，那么需要确保开发环境中已经安装 libasan 库，如果没有可以参考如下命令:

{% highlight c %}
# Running on Ubuntu
sudo apt-get install -y libasan
{% endhighlight %}

GUN GCC 和 libasan 准备好之后，开发者可以部署实践所需的源码，在 BiscuitOS 中，源码的部署可以参考:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] GCC Address Sanitizer Tools (ASAN)  --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-default
{% endhighlight %}

> [BiscuitOS 独立应用程序实践攻略](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C2)
>
> [BiscuitOS-ASAN-default 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001347.png)

案例代码很简单，在 main() 函数的局部堆栈创建了一个 int 数组 array，其包含 10 个成员。程序运行之后会在 main 函数的堆栈中分配 10 个 int 长度的内存用于作为 array[] 数组，这个数组也就是堆栈缓冲区。程序接着将 array[10] 的值赋值为 0x20, 由于 array[] 数组只有 10 个成员，分别是 array[0] 到 array[9], 那么显然 array[10] 已经超出了堆栈缓冲区的范围，那么称这种内存错误为堆栈缓存区溢出，或者是堆栈溢出 stack overflow. 这里虽然只是使用了一个简单的例子进行说明，可以一眼看出问题的所在，但是开发者在开发复杂程序的过程中，想通过眼里查找隐藏很深的堆栈溢出，那么是一件很棘手的事，这个时候 ASAN 工具就派上了用场。由于 ASAN 工具的插桩模块是在程序编译的时候进行插入，那么需要在编译程序时添加如下编译选项:

{% highlight c %}
# CFLAGS for GCC
CFLAGS += -fsanitize=leak
CFLAGS += -fsanitize=address
CFLAGS += -fno-omit-frame-pointer
CFLAGS += -fno-optimize-sibling-calls -O1 -g
#CFLAGS += -fsanitize=memory
{% endhighlight %}

'-fsanitize=leak' 选项用于跟踪程序内存泄露，'-fsanitize=address' 选项可以跟踪堆栈缓冲区溢出，另外加上几个调试使用的选项，以便使用 GDB 或者 OBJDUMP 工具获得更多的调试信息。接下来基于 BiscuitOS 编译架构对源码进行编译，编译成功之后会生成如下文件:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001349.png)

编译完成之后会生成两个版本的文件，其中一个是带 ASAN 工具的版本，另外一个是不带 ASAN 的原始版本, BiscuitOS-ASAN-default 目录下各文件的含义如下:

* main.c 源码文件
* Makefile 编译文件
* BiscuitOS-ASAN-default-Prep.i 带 ASAN 工具的预处理文件
* BiscuitOS-ASAN-default-ASM.s 带 ASAN 工具的汇编文件
* BiscuitOS-ASAN-default-obj.o 带 ASAN 工具的中间文件
* BiscuitOS-ASAN-default-Object.obs 带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-default 带 ASAN 工具的可执行二进制文件
* BiscuitOS-ASAN-default-target.obs BiscuitOS-ASAN-default 反汇编文件
* BiscuitOS-ASAN-default-Prep-NOASAN.i 不带 ASAN 预处理文件
* BiscuitOS-ASAN-default-ASM-NOASAN.s 不带 ASAN 汇编文件
* BiscuitOS-ASAN-default-obj-NOASAN.o 不带 ASAN 中间文件
* BiscuitOS-ASAN-default-Object-NOASAN.obs 不带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-default-NOASAN 不带 ASAN 的可执行二进制文件
* BiscuitOS-ASAN-default-target-NOASAN.obs 不带 ASAN 可执行文件的反汇编文件

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001350.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001346.png)

由于 BiscuitOS-ASAN-default-NOASAN 可执行文件不带 ASAN 工具，那么其运行时直接导致进程 Abort 退出，而 BiscuitOS-ASAN-default 可执行文件带 ASAN 工具，并在程序运行发生内存问题时直接停止运行，并打印相应的信息，其信息相应的含义如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001351.png)

ASAN 工具打印的第一部分信息如上图，红色字符串打印了第一次出现内存错误的位置，其中 "AddressSanitizer" 字段指明了是 ASAN 工具集的 AddressSanitizer 工具发现了内存问题。接着 "stack-buffer-overflow" 字段指明了发生内存问题的类型，这里是堆栈缓冲区溢出导致的内存问题。"address 0x7ffe8272ff78" 字段指明了发生内存问题的虚拟内存地址，"pc 0x5616d02daa0e bp 0x7ffe8272ff20 sp 0x7ffw8272ff10" 字段则指明了发生内存问题是进程的 PC 寄存器、BP 寄存器以及 SP 寄存器的值. 接下来蓝色字段 "WRITE of size 4 at 0x7ffe8272ff78 thread T0" 指明了发生内存问题是进程的动作，这里可以看到发生内存问题时线程 T0 正在向虚拟地址 0x7ffe8272ff78 写入一个 4 字节的值，这个正好对应了源码 "array[10] = 0x20" 的字段。最后一部分内容就是发生内存问题是进程的调用栈信息，可以看到进程 BiscuitOS-ASAN-default 从其 0x849 处的 \_start 开始运行，然后调用 libc 的 \_\_libc_start_main 接口，最后就是运行到 main.c 的第 19 行处发生了内存问题。通过上面的信息基本可以定位了发生内存问题的位置，那么接下来继续分析其他信息:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001352.png)

ASAN 工具打印的第二部分信息如上图，首先绿色字符串打印发生内存问题的虚拟地址的位置，可以从图中看出该虚拟内存位于 T0 线程的堆栈偏移 72 字节处，接下来的 '#0' 表示堆栈的位置，可以看出位于 main.c 文件的 16 行，此处正好是 array[] 数组定义的位置，接下来就是具体堆栈的信息，可以看出 array[] 数组在堆栈的范围是 "\[32,72\)", 接着绿色字符串指出了方式内存问题的操作是内存访问了堆栈 72 字节处，但这里已经导致了 array[] 数组的越界。接下来 ASAN 工具打印了 HINT 信息，该信息是 ASAN 的一些建议。最后一部分信息 "SUMMARY" 字符串是 ASAN 对这次内存问题的总结, "AddressSanitizer" 指明 ASAN 的 Address Sanitizer 工具发现的内存问题，内存问题类型是 stack buffer overflow 即栈缓存溢出，最后将发生栈溢出的位置标记出来，此时为 main.c 文件的 19 行，即 "array[10] = 0x20" 代码行。通过上面的信息可以准确定位内存问题的位置，那么接下来就是 ASAN 内部调试使用的信息字段:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001353.png)

根据 ASAN 的实现原理，ASAN 会从进程的地址空间申请一部分内存作为 Shadow Memory, 这部分 Shadow Memory 用于表示进程跟踪内存的使用情况，这里不对 ASAN 实现原理进行简介，如果想了解其实现原理，开发者可以参考《[ASAN 实现原理分析](#D1)》. ASAN 此时打印第三部分内容就是关于 Shadow Memory 的，ASAN 将出现内存问题的虚拟内存在 Shadow Memory 中打印出来，例如 0x7ffe8272ff78 的标记信息位于 Shadow Memory 区域的 0x1000504ddfef 处，此时标志的值为 f2，那么此时 ASAN 打印了 "Shadow bytes legend", 可以看出 f2 对应的内存错误信息是 "Stack mid redzone". 至此一次 ASAN 的使用到此为止，接下来开发者可以在本文多个章节的提示下可以对 ASAN 工具进一步研究.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)


--------------------------------------

<span id="C0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000T.jpg)

#### ASAN 解析悬浮指针/野指针案例

悬浮指针指的是声明了但没有赋值的指针，它指向内存中的随机位置，悬浮指针的危害很大，它会将进程的内存进行破坏，给进程带来未知的问题。避免悬浮指针的一个方式就是在声明之后将悬浮指针设置为 NULL，这样可以使用 if 语句判断出来。另外与悬浮指针相类似的就是野指针，野指针不是 NULL 指针，而是指向 "垃圾" 内存的指针，所谓 "垃圾" 内存就是已经释放的内存。野指针的形成有两种途径: **第一种途径是指针没有初始化**. 任何指针变量刚创建时不会自动设置为 NULL 指针，它的缺省值是随机的，指向未知的位置，所以指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么将指针指向合法的内存. **第二种途径是指针被 free 或者 delete 之后，没有设置为 NULL, 让程序误认为指针是合法指针**。free 和 delete 只是把指针指向的内存释放掉，但没有把指针本身释放掉，因此指针如果没有设置为 NULL 之后会形成野指针。

ASAN 工具可以检测 C/C++ 程序中使用悬浮指针和野指针的情况，ASAN 将这类型的内存问题归类为 Heap use after free, 也就是使用了已经释放的堆内存。接下来使用一个案例进行讲解, BiscuitOS 部署逻辑如下:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] ASAN: Heap use after free (C Version) --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-heap-use-after-free-default
{% endhighlight %}

> [BiscuitOS 独立应用程序实践攻略](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C2)
>
> [BiscuitOS-ASAN-heap-use-after-free-default 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN-heap-use-after-free)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001354.png)

案例代码很简单，定义了 func() 函数，函数内部定义了一个指针 p，并初始化为 NULL，然后申请一块内存，并将指针 p 指向新内存，接着有调用 free() 函数回收了这段内存，最后函数 func() 返回了指针 p 的值。main() 函数定义了一个变量 p，并调用 func() 函数, 并将 func() 函数的返回值作为变量 p 的初始值。从代码逻辑可以知道，在 25 行处，p 指向的内存已经变成 "垃圾" 内存，这个时候再从 "垃圾" 内存上读取内容，那么这些内存都是无效的。如果这种内存错误发生在比较复杂的场景中，那么无法通过判断 func() 的返回值来确认内容是否有效，这个棘手问题就需要 ASAN 工具进行排查。由于 ASAN 工具的插桩模块是在程序编译的时候进行插入，那么需要在编译程序时添加如下编译选项:

{% highlight c %}
# CFLAGS for GCC
CFLAGS += -fsanitize=leak
CFLAGS += -fsanitize=address
CFLAGS += -fno-omit-frame-pointer
CFLAGS += -fno-optimize-sibling-calls -O1 -g
#CFLAGS += -fsanitize=memory
{% endhighlight %}

'-fsanitize=leak' 选项用于跟踪程序内存泄露，'-fsanitize=address' 选项可以跟踪堆栈缓冲区溢出，另外加上几个调试使用的选项，以便使用 GDB 或者 OBJDUMP 工具获得更多的调试信息。接下来基于 BiscuitOS 编译架构对源码进行编译，编译成功之后会生成如下文件:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001355.png)

编译完成之后会生成两个版本的文件，其中一个是带 ASAN 工具的版本，另外一个是不带 ASAN 的原始版本, BiscuitOS-ASAN-heap-use-after-free-default 目录下各文件的含义如下:

* main.c 源码文件
* Makefile 编译文件
* BiscuitOS-ASAN-XX-Prep.i 带 ASAN 工具的预处理文件
* BiscuitOS-ASAN-XX-ASM.s 带 ASAN 工具的汇编文件
* BiscuitOS-ASAN-XX-obj.o 带 ASAN 工具的中间文件
* BiscuitOS-ASAN-XX-Object.obs 带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-XX 带 ASAN 工具的可执行二进制文件
* BiscuitOS-ASAN-XX-target.obs BiscuitOS-ASAN-XX 反汇编文件
* BiscuitOS-ASAN-XX-Prep-NOASAN.i 不带 ASAN 预处理文件
* BiscuitOS-ASAN-XX-ASM-NOASAN.s 不带 ASAN 汇编文件
* BiscuitOS-ASAN-XX-obj-NOASAN.o 不带 ASAN 中间文件
* BiscuitOS-ASAN-XX-Object-NOASAN.obs 不带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-XX-NOASAN 不带 ASAN 的可执行二进制文件
* BiscuitOS-ASAN-XX-target-NOASAN.obs 不带 ASAN 可执行文件的反汇编文件

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001356.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001357.png)

由于 BiscuitOS-ASAN-heap-use-after-free-NOASAN 可执行文件不带 ASAN 工具，那么其运行时系统并未发现有野指针的存在，那么程序并没有报错。相反 由于 BiscuitOS-ASAN-heap-use-after-free 可执行文件带了 ASAN 工具，那么程序运行的时候，ASAN 工具发现了野指针，因此 ASAN 工具中断的程序的执行，并打印相应的信息。其信息具体含义如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001358.png)

ASAN 工具打印的第一部分信息如上图，红色字符串打印了第一次出现内存错误的位置，其中 "AddressSanitizer" 字段指明了是 ASAN 工具集的 AddressSanitizer 工具发现了内存问题。接着 "heap-use-after-free" 字段指明了发生内存问题的类型，这里是悬浮制作或者野指针导致的内存问题。"address 0x602000000010" 字段指明了发生内存问题的虚拟内存地址，"pc 0x563d840238cf bp 0x7ffc7e7b34e0 sp 0x7ffc7e7b34d0" 字段则指明了发生内存问题是进程的 PC 寄存器、BP 寄存器以及 SP 寄存器的值. 接下来蓝色字段 "READ of size 4 at 0x602000000010 thread T0" 指明了发生内存问题时进程的动作，这里可以看到发生内存问题时线程 T0 正在向读取虚拟地址 0x602000000010 处一个 4 字节的值，这个正好对应了源码 25 行处。最后一部分内容就是发生内存问题是进程的调用栈信息，可以看到进程 BiscuitOS-ASAN-heap-use-after-free-default 从其 0x7a9 处的 \_start 开始运行，然后调用 libc 的 \_\_libc_start_main 接口，接着 main.c 文件 30 行处调用 func() 函数，最后就是运行到 main.c 的第 25 行处发生了内存问题。通过上面的信息基本可以定位了发生内存问题的位置，那么接下来继续分析其他信息:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001359.png)

ASAN 工具打印的第二部分信息如上图，首先绿色字符串打印了发生内存问题的堆信息，其在堆中的范围是 0x602000000010 到 0x602000000014。接着第一个调用栈表明了发生内存问题堆的释放过程，可以看出 main() 函数调用 func() 函数，并且在 main.c 文件的 22 行将堆内存进行回收，这个时候这部分堆内存是 "垃圾" 内存, 最后 libasan 的 \_\_interceptor_free() 函数接管了 free() 函数，并监听 "垃圾" 内存. 第二个函数调用栈是堆内存的分配过程，可以看出 main() 函数调用 func() 函数，并在 main.c 文件的 20 行处分配堆内存，并使用 \_\_interceptor_malloc() 函数接管了 malloc() 函数，对堆内存进行监听. ASAN 工具第三部分信息是对这个内存问题的总结，其表明 AddressSanitizer 工具在 main.c 文件的 25 行处发现了 heap-use-after-free 类型的内存错误。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001360.png)

根据 ASAN 的实现原理，ASAN 会从进程的地址空间申请一部分内存作为 Shadow Memory, 这部分 Shadow Memory 用于表示进程跟踪内存的使用情况，这里不对 ASAN 实现原理进行简介，如果想了解其实现原理，开发者可以参考《[ASAN 实现原理分析](#D1)》. ASAN 此时打印第三部分内容就是关于 Shadow Memory 的，ASAN 将出现内存问题的虚拟内存在 Shadow Memory 中打印出来，例如 0x602000000010 的标记信息位于 Shadow Memory 区域的 0x0c047fff8002 处，此时标志的值为 fd，那么此时 ASAN 打印了 "Shadow bytes legend", 可以看出 fd 对应的内存错误信息是 "Free heap region". 至此一次 ASAN 的使用到此为止, 案例只给出一个简单的例子，更多的例子可以参考:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] ASAN: Heap use after free (C++ Version) --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-heap-use-after-free-default-CPP
{% endhighlight %}

> [BiscuitOS-ASAN-heap-use-after-free-default-CPP 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN-heap-use-after-free-CPP)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001361.png)

上图案例是一个简单的 C++ 程序，其 new 新建了一个数组对象，接着又 delete 这个数组对象，最后在 22 行还使用这个数组对象，因此造成了 heap-use-after-free 的内存问题.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------------

<span id="C1"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000I.jpg)

#### ASAN 解析堆溢出案例

进程的地址空间被分作堆、栈、MMAP 区域、代码段以及数据段等多个区域，进程可以从不同的区域获得虚拟内存，其中从堆上获得的内存称为堆内存。进程的堆一般位于进程的数据段或者 BSS 段之后，其向高地址生长。进程通过 malloc() 等函数分配的小粒度内存块基本来自堆内存。堆内存溢出表示进程访问内存时超出了堆的访问范围，那么称这类型的内存问题为堆缓冲区溢出。一般在简单的程序开发中容易发现该类型的问题，但在大型项目中要发现这类型的问题特别困难，首先函数调用时返回的堆内容不是 NULL 或者关键值，那么就不能通过 if 语句进行判断。为了更好的发现问题，那么可以使用 GUN GCC 的 ASAN 工具进行检测。ASAN 工具可以检测 C/C++ 程序中堆缓冲溢出的情况，ASAN 将这类型的内存问题归类为 Heap buffer overflow。接下来使用一个案例进行讲解, BiscuitOS 部署逻辑如下:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] ASAN: Heap buffer overflow (C Version) --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-heap-buffer-overflow-default
{% endhighlight %}

> [BiscuitOS 独立应用程序实践攻略](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C2)
>
> [BiscuitOS-ASAN-heap-buffer-overflow-default 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN-heap-buffer-overflow)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001362.png)

案例代码很简单，在 main() 函数内部定义了一个 int 类型的指针 p，然后使用 malloc() 函数从进程的堆上分配了 8 个 int 长度的内存，接着函数在 23 行通过越界的方式给 p[8] 赋值，正常的程序无法察觉这个错误，因为 malloc() 函数在分配堆内存的时候都会按 8 字节或者 16、32 字节方式对齐，这样就导致 malloc() 函数实际分配的内存会大于原始内存，那么进程对这部分多余内存的使用并不会被系统察觉有什么异样，但就是这样的操作存在隐患。函数接着在 26 行调用 free() 函数释放了这段堆内存，并在 28 行返回了 p[8] 的值。由于 ASAN 工具的插桩模块是在程序编译的时候进行插入，那么需要在编译程序时添加如下编译选项:

{% highlight c %}
# CFLAGS for GCC
CFLAGS += -fsanitize=leak
CFLAGS += -fsanitize=address
CFLAGS += -fno-omit-frame-pointer
CFLAGS += -fno-optimize-sibling-calls -O1 -g
#CFLAGS += -fsanitize=memory
{% endhighlight %}

'-fsanitize=leak' 选项用于跟踪程序内存泄露，'-fsanitize=address' 选项可以跟踪堆栈缓冲区溢出，另外加上几个调试使用的选项，以便使用 GDB 或者 OBJDUMP 工具获得更多的调试信息。接下来基于 BiscuitOS 编译架构对源码进行编译，编译成功之后会生成如下文件:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001363.png)

编译完成之后会生成两个版本的文件，其中一个是带 ASAN 工具的版本，另外一个是不带 ASAN 的原始版本, BiscuitOS-ASAN-heap-buffer-overflow-default 目录下各文件的含义如下:

* main.c 源码文件
* Makefile 编译文件
* BiscuitOS-ASAN-XX-Prep.i 带 ASAN 工具的预处理文件
* BiscuitOS-ASAN-XX-ASM.s 带 ASAN 工具的汇编文件
* BiscuitOS-ASAN-XX-obj.o 带 ASAN 工具的中间文件
* BiscuitOS-ASAN-XX-Object.obs 带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-XX 带 ASAN 工具的可执行二进制文件
* BiscuitOS-ASAN-XX-target.obs BiscuitOS-ASAN-XX 反汇编文件
* BiscuitOS-ASAN-XX-Prep-NOASAN.i 不带 ASAN 预处理文件
* BiscuitOS-ASAN-XX-ASM-NOASAN.s 不带 ASAN 汇编文件
* BiscuitOS-ASAN-XX-obj-NOASAN.o 不带 ASAN 中间文件
* BiscuitOS-ASAN-XX-Object-NOASAN.obs 不带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-XX-NOASAN 不带 ASAN 的可执行二进制文件
* BiscuitOS-ASAN-XX-target-NOASAN.obs 不带 ASAN 可执行文件的反汇编文件

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001364.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001365.png)

由于 BiscuitOS-ASAN-heap-buffer-overflow-NOASAN 可执行文件不带 ASAN 工具，那么其运行时系统并未发现堆栈缓冲区溢出问题，那么程序并没有报错。相反由于 BiscuitOS-ASAN-heap-buffer-overflow-default 可执行文件带了 ASAN 工具，那么程序运行的时候，ASAN 工具发现了堆缓冲区溢出问题，因此 ASAN 工具中断的程序的执行，并打印相应的信息。其信息具体含义如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001366.png)

ASAN 工具打印的第一部分信息如上图，红色字符串打印了第一次出现内存错误的位置，其中 "AddressSanitizer" 字段指明了是 ASAN 工具集的 AddressSanitizer 工具发现了内存问题。接着 "heap-buffer-overflow" 字段指明了发生内存问题的类型，这里是堆缓冲区溢出导致的内存问题。"address 0x603000000030" 字段指明了发生内存问题的虚拟内存地址，"pc 0x55ba895538d1 bp 0x7ffc6e0f9640 sp 0x7ffc6e0f9630" 字段则指明了发生内存问题是进程的 PC 寄存器、BP 寄存器以及 SP 寄存器的值. 接下来蓝色字段 "READ of size 4 at 0x602000000030 thread T0" 指明了发生内存问题时进程的动作，这里可以看到发生内存问题时线程 T0 正在向读取虚拟地址 0x602000000030 处一个 4 字节的值，这个正好对应了源码 28 行处。最后一部分内容就是发生内存问题是进程的调用栈信息，可以看到进程 BiscuitOS-ASAN-heap-buffer-overflow-default 从其 0x7a9 处的 \_start 开始运行，然后调用 libc 的 \_\_libc_start_main 接口，最后运行到 main.c 的第 28 行处发生了内存问题。通过上面的信息基本可以定位了发生内存问题的位置，那么接下来继续分析其他信息:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001367.png)

ASAN 工具打印的第二部分信息如上图，首先绿色字符串打印了发生内存问题的堆信息，其在堆中的范围是 0x602000000010 到 0x602000000030。接着第一个调用栈表明了发生内存问题堆的释放过程，可以看出在 main.c 文件的 26 行将堆内存进行回收，这个时候这部分堆内存是 "垃圾" 内存, 最后 libasan 的 \_\_interceptor_free() 函数接管了 free() 函数，并监听 "垃圾" 内存. 第二个函数调用栈是堆内存的分配过程，可以看出 main.c 文件的 20 行处分配堆内存，并使用 \_\_interceptor_malloc() 函数接管了 malloc() 函数，对堆内存进行监听. ASAN 工具第三部分信息是对这个内存问题的总结，其表明 AddressSanitizer 工具在 main.c 文件的 28 行处发现了 heap-buffer-overflow 类型的内存错误.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001368.png)

根据 ASAN 的实现原理，ASAN 会从进程的地址空间申请一部分内存作为 Shadow Memory, 这部分 Shadow Memory 用于表示进程跟踪内存的使用情况，这里不对 ASAN 实现原理进行简介，如果想了解其实现原理，开发者可以参考《[ASAN 实现原理分析](#D1)》. ASAN 此时打印第三部分内容就是关于 Shadow Memory 的，ASAN 将出现内存问题的虚拟内存在 Shadow Memory 中打印出来，例如 0x602000000030 的标记信息位于 Shadow Memory 区域的 0x0c067fff8000 处，此时标志的值为 fa，那么此时 ASAN 打印了 "Shadow bytes legend", 可以看出 fd 对应的内存错误信息是 "Heap left redzone". 至此一次 ASAN 的使用到此为止, 案例只给出一个简单的例子，更多的例子可以参考:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] ASAN: Heap buffer overflow (C++ Version) --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-heap-buffer-overflow-default-CPP
{% endhighlight %}

> [BiscuitOS-ASAN-heap-buffer-overflow-default-CPP 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN-heap-buffer-overflow-CPP)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001369.png)

上图案例是一个简单的 C++ 程序，其 new 新建了一个数组对象，接着在 20 行处越界方式向 array[8] 写入值，又 delete 这个数组对象，最后在 25 行还使用这个数组对象，因此造成了 heap-buffer-overflow 的内存问题.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------------

<span id="C2"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000F.jpg)

#### ASAN 解析栈溢出案例

进程的地址空间被分作堆、栈、MMAP 区域、代码段以及数据段等多个区域，进程可以从不同的区域获得虚拟内存，其中从栈上获得的内存称为栈内存。进程的栈位于地址空间的顶部，一般情况下向下生长。进程定义的局部变量均来自堆栈内存。栈内存溢出表示进程访问内存时超出了栈的访问范围，那么称这类型的内存问题为栈缓冲区溢出。一般在简单的程序开发中容易发现该类型的问题，但在大型项目中要发现这类型的问题特别困难，首先函数的堆栈大于变量的大小，进程可以在非法的情况下使用越界的堆栈，但程序认为其位于堆栈内部，因此不会判定为堆栈溢出。为了更好的发现问题，那么可以使用 GUN GCC 的 ASAN 工具进行检测。ASAN 工具可以检测 C/C++ 程序中栈缓冲区溢出的情况，ASAN 将这类型的内存问题归类为 Stack buffer overflow。接下来使用一个案例进行讲解, BiscuitOS 部署逻辑如下:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] ASAN: Stack buffer overflow (C Version) --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-stack-buffer-overflow-default
{% endhighlight %}

> [BiscuitOS 独立应用程序实践攻略](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C2)
>
> [BiscuitOS-ASAN-stack-buffer-overflow-default 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN-stack-buffer-overflow)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001370.png)

案例代码很简单，在 main() 函数内定义了一个局部数组 array[], 其包含了 10 个成员，接着在 19 行处对 array[10] 成员进行写操作，这样将会导致 array[] 数组溢出，函数最后返回 0. 在简单的程序中这种错误很容易发现，但在大型复杂程序中，这种问题很难被发现，因此可以使用 ASAN 工具对堆栈缓冲区溢出问题进行检查。由于 ASAN 工具的插桩模块是在程序编译的时候进行插入，那么需要在编译程序时添加如下编译选项:

{% highlight c %}
# CFLAGS for GCC
CFLAGS += -fsanitize=leak
CFLAGS += -fsanitize=address
CFLAGS += -fno-omit-frame-pointer
CFLAGS += -fno-optimize-sibling-calls -O1 -g
#CFLAGS += -fsanitize=memory
{% endhighlight %}

'-fsanitize=leak' 选项用于跟踪程序内存泄露，'-fsanitize=address' 选项可以跟踪堆栈缓冲区溢出，另外加上几个调试使用的选项，以便使用 GDB 或者 OBJDUMP 工具获得更多的调试信息。接下来基于 BiscuitOS 编译架构对源码进行编译，编译成功之后会生成如下文件:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001371.png)

编译完成之后会生成两个版本的文件，其中一个是带 ASAN 工具的版本，另外一个是不带 ASAN 的原始版本, BiscuitOS-ASAN-stack-buffer-overflow-default 目录下各文件的含义如下:

* main.c 源码文件
* Makefile 编译文件
* BiscuitOS-ASAN-XX-Prep.i 带 ASAN 工具的预处理文件
* BiscuitOS-ASAN-XX-ASM.s 带 ASAN 工具的汇编文件
* BiscuitOS-ASAN-XX-obj.o 带 ASAN 工具的中间文件
* BiscuitOS-ASAN-XX-Object.obs 带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-XX 带 ASAN 工具的可执行二进制文件
* BiscuitOS-ASAN-XX-target.obs BiscuitOS-ASAN-XX 反汇编文件
* BiscuitOS-ASAN-XX-Prep-NOASAN.i 不带 ASAN 预处理文件
* BiscuitOS-ASAN-XX-ASM-NOASAN.s 不带 ASAN 汇编文件
* BiscuitOS-ASAN-XX-obj-NOASAN.o 不带 ASAN 中间文件
* BiscuitOS-ASAN-XX-Object-NOASAN.obs 不带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-XX-NOASAN 不带 ASAN 的可执行二进制文件
* BiscuitOS-ASAN-XX-target-NOASAN.obs 不带 ASAN 可执行文件的反汇编文件

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001372.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001373.png)

由于 BiscuitOS-ASAN-stack-buffer-overflow-NOASAN 可执行文件不带 ASAN 工具，那么其运行时系统只是发现堆栈出问题了，但不知道堆栈怎么出问题了。相反由于 BiscuitOS-ASAN-stack-buffer-overflow-default 可执行文件带了 ASAN 工具，那么程序运行的时候，ASAN 工具发现了栈缓冲区溢出问题，因此 ASAN 工具中断的程序的执行，并打印相应的信息。其信息具体含义如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001374.png)

ASAN 工具打印的第一部分信息如上图，红色字符串打印了第一次出现内存错误的位置，其中 "AddressSanitizer" 字段指明了是 ASAN 工具集的 AddressSanitizer 工具发现了内存问题。接着 "stack-buffer-overflow" 字段指明了发生内存问题的类型，这里是栈缓冲区溢出导致的内存问题。"address 0x7ffc5810cc58" 字段指明了发生内存问题的虚拟内存地址，"pc 0x56443c39ea0e bp 0x7ffc5810cc00 sp 0x7ffc5810cbf0" 字段则指明了发生内存问题是进程的 PC 寄存器、BP 寄存器以及 SP 寄存器的值. 接下来蓝色字段 "WRITE of size 4 at 0x7ffc5810cc58 thread T0" 指明了发生内存问题时进程的动作，这里可以看到发生内存问题时线程 T0 正在向虚拟地址 0x7ffc5810cc58 处写入一个 4 字节的值，这个正好对应了源码 20 行处。最后一部分内容就是发生内存问题是进程的调用栈信息，可以看到进程 BiscuitOS-ASAN-stack-buffer-overflow-default 从其 0x7a9 处的 \_start 开始运行，然后调用 libc 的 \_\_libc_start_main 接口，最后运行到 main.c 的第 20 行处发生了内存问题。通过上面的信息基本可以定位了发生内存问题的位置，那么接下来继续分析其他信息:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001375.png)

ASAN 工具打印的第二部分信息如上图，首先绿色字符串打印了发生内存问题的栈信息，信息指明错误虚拟地址位于 T0 线程的堆栈 72 字节处，其堆缓冲区位于 main.c 的 16 行处，此处正好都是 array[] 数组定义的位置. ASAN 工具第三部分信息是对这个内存问题的总结，其表明 AddressSanitizer 工具在 main.c 文件的 20 行处发现了 stack-buffer-overflow 类型的内存错误.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001376.png)

根据 ASAN 的实现原理，ASAN 会从进程的地址空间申请一部分内存作为 Shadow Memory, 这部分 Shadow Memory 用于表示进程跟踪内存的使用情况，这里不对 ASAN 实现原理进行简介，如果想了解其实现原理，开发者可以参考《[ASAN 实现原理分析](#D1)》. ASAN 此时打印第三部分内容就是关于 Shadow Memory 的，ASAN 将出现内存问题的虚拟内存在 Shadow Memory 中打印出来，例如 0x7ffc5810cc58 的标记信息位于 Shadow Memory 区域的 0x10000b01998b 处，此时标志的值为 f2，那么此时 ASAN 打印了 "Shadow bytes legend", 可以看出 f2 对应的内存错误信息是 "Stack mid redzone". 至此一次 ASAN 的使用到此为止, 案例只给出一个简单的例子，更多的例子可以参考:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] ASAN: Stack buffer overflow (C++ Version) --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-stack-buffer-overflow-default-CPP
{% endhighlight %}

> [BiscuitOS-ASAN-stack-buffer-overflow-default-CPP 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN-stack-buffer-overflow-CPP)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001377.png)

上图案例是一个简单的 C++ 程序，其在 main() 函数内部创建了局部变量 array[] 数组，数组的长度只有 10，然而 19 行位置将 0x88 写入了 array[10], 此时已经越界了，因此 ASAN 工具可以抓到 stack-buffer-overflow 内存错误.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------------

<span id="C3"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000G.jpg)

#### ASAN 解析全局缓冲区溢出案例

进程的地址空间被分作堆、栈、MMAP 区域、代码段以及数据段等多个区域，进程可以从不同的区域获得虚拟内存，其中全局缓冲区位于数据段或者 BSS 段上的内存。进程的数据段/BSS 段用于存储进程的全局数据，其中全局缓冲区常见的类型就是全局数组。全局缓冲区内存溢出表示进程访问全局数组时超出了数组的访问范围，那么称这类型的内存问题为全局缓冲区溢出。一般在简单的程序开发中容易发现该类型的问题，但在大型项目中要发现这类型的问题特别困难。为了更好的发现问题，那么可以使用 GUN GCC 的 ASAN 工具进行检测。ASAN 工具可以检测 C/C++ 程序中全局缓冲区溢出的情况，ASAN 将这类型的内存问题归类为 Global buffer overflow。接下来使用一个案例进行讲解, BiscuitOS 部署逻辑如下:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] ASAN: Global buffer overflow (C Version) --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-global-buffer-overflow-default
{% endhighlight %}

> [BiscuitOS 独立应用程序实践攻略](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C2)
>
> [BiscuitOS-ASAN-global-buffer-overflow-default 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN-global-buffer-overflow)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001378.png)

案例代码很简单，在 main.c 文件中定义了一个全局数组 array[], 其包含了 10 个成员，接着在 20 行处对 array[10] 成员进行写操作，这样将会导致 array[] 数组溢出，函数最后返回 0. 在简单的程序中这种错误很容易发现，但在大型复杂程序中，这种问题很难被发现，因此可以使用 ASAN 工具对堆栈缓冲区溢出问题进行检查。由于 ASAN 工具的插桩模块是在程序编译的时候进行插入，那么需要在编译程序时添加如下编译选项:

{% highlight c %}
# CFLAGS for GCC
CFLAGS += -fsanitize=leak
CFLAGS += -fsanitize=address
CFLAGS += -fno-omit-frame-pointer
CFLAGS += -fno-optimize-sibling-calls -O1 -g
#CFLAGS += -fsanitize=memory
{% endhighlight %}

'-fsanitize=leak' 选项用于跟踪程序内存泄露，'-fsanitize=address' 选项可以跟踪堆栈缓冲区溢出，另外加上几个调试使用的选项，以便使用 GDB 或者 OBJDUMP 工具获得更多的调试信息。接下来基于 BiscuitOS 编译架构对源码进行编译，编译成功之后会生成如下文件:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001379.png)

编译完成之后会生成两个版本的文件，其中一个是带 ASAN 工具的版本，另外一个是不带 ASAN 的原始版本, BiscuitOS-ASAN-global-buffer-overflow-default 目录下各文件的含义如下:

* main.c 源码文件
* Makefile 编译文件
* BiscuitOS-ASAN-XX-Prep.i 带 ASAN 工具的预处理文件
* BiscuitOS-ASAN-XX-ASM.s 带 ASAN 工具的汇编文件
* BiscuitOS-ASAN-XX-obj.o 带 ASAN 工具的中间文件
* BiscuitOS-ASAN-XX-Object.obs 带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-XX 带 ASAN 工具的可执行二进制文件
* BiscuitOS-ASAN-XX-target.obs BiscuitOS-ASAN-XX 反汇编文件
* BiscuitOS-ASAN-XX-Prep-NOASAN.i 不带 ASAN 预处理文件
* BiscuitOS-ASAN-XX-ASM-NOASAN.s 不带 ASAN 汇编文件
* BiscuitOS-ASAN-XX-obj-NOASAN.o 不带 ASAN 中间文件
* BiscuitOS-ASAN-XX-Object-NOASAN.obs 不带 ASAN 中间文件的反汇编文件
* BiscuitOS-ASAN-XX-NOASAN 不带 ASAN 的可执行二进制文件
* BiscuitOS-ASAN-XX-target-NOASAN.obs 不带 ASAN 可执行文件的反汇编文件

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001380.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001381.png)

由于 BiscuitOS-ASAN-global-buffer-overflow-NOASAN 可执行文件不带 ASAN 工具，那么程序运行的时候，系统并未发现任何异样。相反由于 BiscuitOS-ASAN-global-buffer-overflow-default 可执行文件带了 ASAN 工具，那么程序运行的时候，ASAN 工具发现了全局缓冲区 array[] 数组溢出问题，因此 ASAN 工具中断的程序的执行，并打印相应的信息。其信息具体含义如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001382.png)

ASAN 工具打印的第一部分信息如上图，红色字符串打印了第一次出现内存错误的位置，其中 "AddressSanitizer" 字段指明了是 ASAN 工具集的 AddressSanitizer 工具发现了内存问题。接着 "global-buffer-overflow" 字段指明了发生内存问题的类型，这里是全局缓冲区溢出导致的内存问题。"address 0x55735f46c0c8" 字段指明了发生内存问题的虚拟内存地址，"pc 0x55735f26b990 bp 0x7fffea8f5380 sp 0x7fffea8f5370" 字段则指明了发生内存问题是进程的 PC 寄存器、BP 寄存器以及 SP 寄存器的值. 接下来蓝色字段 "WRITE of size 4 at 0x55735f46c0c8 thread T0" 指明了发生内存问题时进程的动作，这里可以看到发生内存问题时线程 T0 正在向虚拟地址 0x55735f46c0c8 处写入一个 4 字节的值，这个正好对应了源码 20 行处。最后一部分内容就是发生内存问题是进程的调用栈信息，可以看到进程 BiscuitOS-ASAN-stack-buffer-overflow-default 从其 0x879 处的 \_start 开始运行，然后调用 libc 的 \_\_libc_start_main 接口，最后运行到 main.c 的第 20 行处发生了内存问题。通过上面的信息基本可以定位了发生内存问题的位置，那么接下来继续分析其他信息:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001383.png)

ASAN 工具打印的第二部分信息如上图，首先绿色字符串打印了发生内存问题的栈信息，信息指明错误虚拟地址位于全局变量 array 偏移 40 字节处，其全局缓冲区位于 main.c 的 15 行处，此处正好都是 array[] 数组定义的位置. ASAN 工具第三部分信息是对这个内存问题的总结，其表明 AddressSanitizer 工具在 main.c 文件的 20 行处发现了 global-buffer-overflow 类型的内存错误.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001384.png)

根据 ASAN 的实现原理，ASAN 会从进程的地址空间申请一部分内存作为 Shadow Memory, 这部分 Shadow Memory 用于表示进程跟踪内存的使用情况，这里不对 ASAN 实现原理进行简介，如果想了解其实现原理，开发者可以参考《[ASAN 实现原理分析](#D1)》. ASAN 此时打印第三部分内容就是关于 Shadow Memory 的，ASAN 将出现内存问题的虚拟内存在 Shadow Memory 中打印出来，例如 0x55735f46c0c8 的标记信息位于 Shadow Memory 区域的 0x0aaeebe85810 处，此时标志的值为 f9，那么此时 ASAN 打印了 "Shadow bytes legend", 可以看出 f2 对应的内存错误信息是 "Global redzone". 至此一次 ASAN 的使用到此为止, 案例只给出一个简单的例子，更多的例子可以参考:

{% highlight bash %}
cd BiscuitOS
make menuconfig

[*] Package  --->
    [*]  Memory Sanitizers  --->
        [*] ASAN: Global buffer overflow (C++ Version) --->

OUTPUT:
BiscuitOS/output/linux-XXX-YYY/package/BiscuitOS-ASAN-global-buffer-overflow-default-CPP
{% endhighlight %}

> [BiscuitOS-ASAN-global-buffer-overflow-default-CPP 实践源码 Gitee 链接](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Memory-Allocator/Memory-Sanitizer/BiscuitOS-ASAN-global-buffer-overflow-CPP)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH001385.png)

上图案例是一个简单的 C++ 程序，其在 main.c 文件内创建了全局变量 array[] 数组，数组的长度只有 10，然而 19 行位置将 0x88 写入了 array[10], 此时已经越界了，因此 ASAN 工具可以抓到 global-buffer-overflow 内存错误.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

